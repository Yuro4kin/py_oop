# Наследование
# Мы можем брать ранее созданные классы, выполняющие определенные задачи и, затем, видоизменять их под текущий проект.
# В этом случае  - создается новый класс на основе существующего и дополняется необходимым функционалом.
# Это первый столп (наследование), на котором базируется ООП.
# Наследование - образование новых классов на основе ранее созданных.

# Полиморфизм
# В новом созданном классе можно вызывать ф-ции наследуемого класса так, словно они определены в новом
# Полиморфизм - вызов методов базового класса из дочерних. Программист будет работать с новым классом как с единым объектом.

# Инкапсуляция
# Это возможность закрывать данные и методы класса от внешнего вмешательства.
# Вся работа с классом возможна только через разрешенные интерфейсные методы и реже через данные

# Класс можно воспринимать как некую схему четеж, по которому конструируются его экземпляры
# По такой схеме можно построить множество однотипных домов, т.е. получить множество экземпляров этого класса
#
#                       house              -   класс
#                ^        ^       ^
#              house    house   house      -   экземпляры класса
#
# Определим класс, запишем ключевое слово class, и через пробел указывается его имя с заглавной буквы - PEP8
# Имя класса должно отражать его суть и быть именем существительным
# Класс это некий объект, некая сущность: дом, машина, или точка двумерного пространства
class Point:
    "Класс для определения точек на плоскости"
    x = 1             #  определили две переменные класса Point
    y = 1
                      #  обратимся к той или иной переменной класса:  имя переменной - ставим точку
print(Point.__doc__)  #  описание будет доступно через переменную
print(Point.__name__) #  предопределенное св-во name выводит имя класса
print( dir(Point) )   #  получим полный набор переменных, выполним ф-цию dir() и укажем имя класса Point
                      #  на выходе множество служебных переменных и каждая связана со своими определенными данными

# Создадим экземпляр класса
pt = Point()          #  Переменной pt присвоим ссылку на новый объект
                      #  Записывая имя класса Point с круглыми скобками () мы создаем экземпляр класса
                      #  pt - будет ссылаться на новую построенную точку двумерного пространства
                      # ничеого не выведено в консоль, но экземпляр класса был создан
                      # переменная pt - это пространство имен с именем pt с двумя переменными х,y, которые берутся из класса point
# Если после создания экземпляра класса мы в классе point изменим значение переменной x на 100
Point.x = 100
print( pt.x, pt.y )   # x в экземпляре класса также изменился на 100, но при этом Point и pt - разные объекты
print("x в экземпляре класса также изменился на 100: ", (pt.x, pt.y))

# Проверка по id класса Point и экземпляра pt
# объекты pt и Point разные, но переменная x одна и таже
# переменные x и у берутся из класса Point.
# Если будем создавать другие экземпляры класса, то их переменные х, у - будут браться из класса Point
# Java - это похоже на объявление статических переменных объявленных внутри класса
print( id(pt), id(Point), sep="\n" )
print( "id - pt: " ,id(pt), "id - Point: ", id(Point), sep="\n" )

# Формирование локальных переменных в экземпляре pt (пространстве имен pt) не связанных в классе point
# будут созданы свои переменные x и y c соответствующими значениями, не связанные с классом Point

print("Пустая коллекция из локальных переменных в экземпляре класса pt", pt.__dict__)  # т.к. переменная dict вызвана до формирования локальных переменных в экземпляре класса pt
pt.x = 5          # связи пропадают, в пространстве pt формируются локальные переменные х и у
pt.y = 10
print("Выведем в консоль локальную переменную x экземпляра класса pt и переменную x класса Point: ", pt.x, Point.x )

# Узнаем какие локальные переменные существуют в экземпляре класса
print("В экземпляре класса pt существуют локальные переменные : ", pt.__dict__)        # переменная __dict__ содержит коллекцию из локальных переменных
                                                                                       # в экземпляре класса pt содержатся две переменные x и y

# В терминологии ООП языка Python переменные x, y внутри класса Point или его экземпляров называются атрибутами (или свойствами).
# С атрибутами экземпляров класса можно работать через такие функции:
#  -  getattr(obj, name [, default]) — возвращает значение атрибута объекта;
#  -  hasattr(obj, name) — проверяет на наличие атрибута name в obj;
#  -  setattr(obj, name, value) — задает значение атрибута (если атрибут не существует, то он создается);
#  -  delattr(obj, name) — удаляет атрибут с именем name.
print( "getattr значение атрибута x: ", getattr(pt, "x") )
#print( getattr(pt, "z") )             # Error - атрибут не существует - AttributeError: 'Point' object has no attribute 'z'
print( getattr(pt, "z", False) )       # Error - не будет выводиться на отсутствие атрибута, в консоли будет False
print( hasattr(pt, "z") )              # Возвращает True или False - на наличие атрибута
print( hasattr(pt, "y") )              # Возвращает True или False - на наличие атрибута
setattr(pt, "z", 7)                    # Добавляем атрибут z с значением 7
print("pt: ", pt.__dict__)             # Проверка атрибутов в экземпляре класса pt
delattr(pt, "z")                       # Удаление атрибута z из экземпляра класса pt
print("pt: ", pt.__dict__ )            # Проверка атрибутов в экземпляре класса pt

# Применим ф-ции к атрибутам класса Point
setattr(Point, "z", 7)                 # Добавляем атрибут z с значением 7 к классу Point
print("Point: ", Point.__dict__)       # Проверка атрибутов класса Point
# Добавление атрибутов к классу  Point и экземпляру класса pt без применения ф-ций
Point.zz = 100
pt.msg = "hello"
print("pt: ", pt.__dict__)
#pt.sss                                 # Error - атрибут не существует - AttributeError: 'Point' object has no attribute 'sss'
res = getattr(pt, "sss", False)         # Укажем 3-й аргумент False, переменная res будет принимать значение False, Error ошибки уже не будет
print("getattr - Error - атрибут sss не существует, 3-й аргумент False", res)

# Удаление атрибута оператором del
del pt.msg                      # del - название экземпляра pt и удаляемого атрибута
print("pt: ", pt.__dict__)

# Функция isinstance() - позволяет проверить принадлежность экземпляра к тому или иному классу
print( "pt является экземпляром класса Point: ", isinstance(pt, Point) )
class Point3D:
    pass
print("pt является экземпляром класса Point3D: ", isinstance(pt, Point3D))
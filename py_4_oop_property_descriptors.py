# Объекты-свойства (property)
# мы хотим создать в классе Point создадим свойство coordX
# к которому можно было бы присваивать и считывать значения подобно обычной переменной
# - проводить дополнительные проверки коректности записи-считывания данных
# Для этого воспользуемся готовыми get set ,но сделаем их приватными __get __set
# Не сможем обратиться к ним из вне, через представитель класса pt, а только изнутри класса point
# Используя класс property создаем св-во coordX, которое будет использовать __get _set



class Point:
    def __init__(self, x = 0, y = 0):       # объявлен один конструктор
        self.__x = x; self.__y = y          # два private атрибута

                                            # Добавим проверку на корректность передаваемых данных в методе __checkValue и методе __setCoordX
    def __checkValue (x):                   # объявлен приватный метод __checkValue внутри класса Point, который будет проверять наше значение x, является ли оно числом или не является
                                            # self - не пишется, т.к. сам метод не будет обращаться к какой-либо локальной переменной экземпляра нашего класса
        if isinstance(x, int) or isinstance(x, float): # с помощью ф-ции isinstance проверяем, что x является типом int или float и тоже самое для y
            return True                     # если это так возвращаем True
        return False                        # иначе возвращено False

# Внутри класса Point1 создадим спец. метод -  для записи другого значения, если хотим изменить координату
# Получился метод публичный, открытый getCorrds через который мы можем менять значение закрытых атрибутов __x, __y

# объявление св-в через декораторы
    @property                               # декоратор property перед нашим геттером, имя геттера __getCoordX - меняет на имя св-ва coordX
    def coordX(self):                       # будет называться также, как и будет называться св-во coordX, которое закоментировано ниже
    #def __getCoordX(self):                  # get - геттер
#        print("вызов __getCoordX")          # 2-e сообщение - проверка работы метода
        return self.__x                     # будем возвращать кортеж этих значений

# Внутри класса Point создадим спец. метод -  для записи другого значения, если хотим изменить координату
# Получился метод публичный, открытый setCorrds через который мы можем менять значение закрытых атрибутов __x, __y

    @coordX.setter                           # укажем что этот метод будет сеттером, записываем декоратор будет coordX ставим . и далее пишем setter
    def coordX(self, x):                     # меняем название метода на coordX
#    def __setCoordX(self, x):                # set - сеттер - означает установить, задать, координату Corrds, два параметра x, y
#        print("вызов __setCoordX")          # 1-е сообщение - проверка работы метода
        if Point.__checkValue(x):            # добавим проверку пере
            self.__x = x                     # внутри метода setCorrds через два параметра мы можем обращаться к этим закрытым св-вам
                                             # --- будем присваивать закрытому св-ву__x значение в том случае, если оно действительно является числом
        else:                                # --- если не число, то будет вызываться сообщение "Неверный формат данных"
            raise ValueError("Неверный формат данных")

    @coordX.deleter                          # укажем что этот метод будет deleter, записываем декоратор будет coordX ставим . и далее пишем deleter
    def coordX(self):                        # меняем название метода на coordX
#    def __delCoordX(self):
        print("Удаление свойства")           # будет выводить удаление св-ва, если будем удалять coordX
        del self.__x


#    coordX = property(__getCoordX, __setCoordX, __delCoordX)
                                            # Используя класс property создаем св-во coordX, которое будет использовать __getCoordX, __setCoordX
                                            # Св-во coordX может реагировать на чтение, запись, удаление данных
                                            # метод __delCoordX указывается третим аргументом


pt = Point(1, 2)                            # вызвали конструктор, когда создали экземпляр классa pt
                                            # проверили работоспособность программы - Process finished with exit code 0

pt.coordX = 100                             # запись значения - будет вызываться сеттер метод def __setCoordX
#pt.coordX = "100"                           # условие оказалось ложным и было выполнено условие нашего сеттера - ValueError: Неверный формат данных
x = pt.coordX                               # чтение значения - считываться с него информация - будет вызываться геттер - метод __getCoordX

print( x )                                  # число 100 корректно прочитано из св-ва coordX

del pt.coordX                               # - сделаем удаление св-ва, при выполнении данной операции объект coordX не удаляется, а продолжает существовать
                                            # - мы удаляем приватную переменную __x из нашего экземпляра класса pt
                                            # - мы удаляем локальное св-во del self.__x в методе def __delCoordX(self):
pt.coordX = 7                               # можем заново создать локальное св-во и ошибки не бует
pt.coordX                                   # -- если захотим из нашего св-ва coordX прочитать какое-то значение - AttributeError: 'Point' object has no attribute '_Point__x'
                                            # -- т.к. приватного свойства __x уже не существует



# информация была записана , выведена в консоль и св-во было удалено
# Хорошо, свойство coordX у нас есть. Но нам нужно создать еще одно – coordY. У нас две координаты.
# Как вы понимаете, это, фактически, приведет к дублированию кода для coordX, что не есть хорошо, так как нарушает принцип программирования
# DRY (Don’t Repeat Yourself) – не повторяйся!
# И здесь нам на помощь приходит другой механизм Python – дескрипторы.
# Дескрипторы это класс в котором определены следующие специальные методы

class CoordValue:                           # Дескрипторы это класс CoordValue в котором определены специальные методы get, set, del
                                            # Когда будем работать с данным дескриптором CoordValue, будем обращаться к соответствующему локальному св-ву self.__name, сохраняется в частной переменной  name и далее
                                            # через параметр instance метода __get__ в коллекции __dict__ будем либо брать, либо записывать туда значения [self.__name] = value в методе __set__

                                            # когда будем брать из коллекции __dict__ нужное нам св-во, его нужно сохранить в конструкторе __init__
    def __init__(self, name):               # конструктор чтоб сохранить св-во name
        self.__name = name


    def __get__(self, instance, owner):     # метод get - это геттер дескриптора класса CoordValue
        return instance.__dict__[self.__name] # воспользуемся параметром instance, и будем брать из коллекции __dict__ нужное нам св-во

    def __set__(self, instance, value):     # метод set - это сеттер дескриптора класса CoordValue
        instance.__dict__[self.__name] = value # instance - будет ссылаться на тот экземпляр класса, для которого вызван данный дескриптор
                                            # __dict__ - используя коллекцию __dict__ можем создать там св-во [self.__name] и присвоить ему определенное значение value
                                            # когда вызываем сеттер - то берем переменную instance, она будет ссылаться на экземпляр pt, p1, pt2 - в зависимости из какого экземпляра был вызван дескриптор
                                            # далее создаем локальную переменную __dict__[self.__name] в соответствующем экземпляре pt, pt1, pt2 с нужным значением
                                            # имя берем либо "coordX" или "coordY" --> внутри экземпляров создаются свом локальные переменные coordX, coordY, - они будут разные в экземплярах и хранить будут разные значения



                                             # метод delete пока уберем
#    def __delete__(self, obj):              # метод delete - это дилиттер дескриптора класса CoordValue
#        del self.__value

class Point:                                # когда будем вызывать конструктор класса CoordValue, нужно передать параметр, а именно имя нашей локальной переменной "coordX", "coordY"
    coordX = CoordValue("coordX")           # в классе Point создадим два экземпляра класса CoordValue
    coordY = CoordValue("coordY")           # на экземпляр класса CoordValue будут ссылаться переменные coordX, coordY
                                            # переменные coordX, coordY - это дескрипторы
                                            # дескрипторы coordX, coordY - представлены двумя объектами __name="coordX" __name="coordY"
                                            # внутри объектов __name="coordX" __name="coordY" сохраняем имена локальных св-в с которыми мы будем работать в экземплярах классов
                                            # экземпляры классов self.coordX хранит ссылку на объект __name="coordX"
                                            # экземпляры классов self.coordY хранит ссылку на объект __name="coordY"


    def __init__(self, x = 0, y = 0):       # объявлен один конструктор
        self.coordX = x                     # дескрипторам будем передавать определенные значения x, y
        self.coordY = y




pt = Point(1, 2)                            # вызвали конструктор, когда создали экземпляр классa pt
                                            # проверили работоспособность программы - Process finished with exit code 0

pt.coordX = 5                               # использование дескрипторов как обычных свойств - изменили значение coordX на 5
print(pt.coordX, pt.coordY)                 # сначала когда создавали экземпляр класса pt, было записано (1, 2)
#print( id(pt.coordX), id(Point.coordX) )    # проверка на равенство дескрипторов по id
                                            # берем дескрипторы непосредственно из класса Point, т.е. обращаемся к объекту __value
                                            # когда выполняется операция self.coordX = x, то self из метода __set__ сеттера строки  (self, instance, value) ссылается на первый объект __value, т.е. браться coordX
                                            # когда выполняется операция self.coordY = y, то self из метода __set__ сеттера строки  (self, instance, value) ссылается на второй объект __value, т.е. браться coordY
                                            # и далее в переменную value будет занесено значение x или y

# идентичность свойств всех наших объектов, если создадим еще один экземпляр класса
# свойства всех наших объектов оказываются идентичными
pt1 = Point(10, 20)
pt2 = Point(30, 40)
print(pt1.coordX, pt1.coordY)               # pt1 self.coordX --> ссылается на класс Point дескриптор coordX  } __value
print(pt2.coordX, pt2.coordY)               # pt2 self.coordX --> ссылается на класс Point дескриптор coordX  } __value - будут работать с темиже самыми объектами, что экземпляр класса
                                            # поправим программу, чтоб координаты точек хранились непосредственно в экземплярах классов - перепишем дескриптор

# С версии Python 3.6+ появился новый метод __set_name__(self, owner, name):
# метод вызывается автоматически при создании соответствующего дескриптора и в параметре name хранится имя экземпляра класса
class CoordValue1:  # Дескрипторы это класс CoordValue1 в котором определены специальные методы get, set, del

    def __set_name__(self, owner, name):            # вместо конструктора __init__ пропишем метод __set_name__, параметр name в (self, owner, name)
        print(name)                                 # будет принимать значение coordX, затем coordY в классе Point1  // вывели в консоль coordX coordY - проверка - потому что выводили имя
        self.__name = name                          # в частной переменной __name сохраняем имя name и потом его используем в качетсве ключа к доступам локальным переменным экземпляров классов
                                                    # __set_name__ сначала будет принимать значение coordX , затем coordY

    def __get__(self, instance, owner):
        return instance.__dict__[self.__name]       #  name используем в качетсве ключа к доступам локальным переменным экземпляров классов

    def __set__(self, instance, value):
        instance.__dict__[self.__name] = value

class Point1:
    coordX = CoordValue1()                   # уберем "coordX" - при создании объекта дескриптора coordX не нужно указывать имена
    coordY = CoordValue1()                   # уберем "coordY" - при создании объекта дескриптора coordY не нужно указывать имена


    def __init__(self, x = 0, y = 0):
        self.coordX = x                     # приоритет отдается coordX дескриптору, а не как локальной переменной экземпляра класса pt
        self.coordY = y                     # self.coordY = y - выполняется как дескриптор, а не как локальная переменная

pt1 = Point1(5, 6)
pt2 = Point1(50, 60)
print(pt1.coordX, pt1.coordY)               # локальные атрибуты coordX, coordY экземпляров классов pt и доступ к дескрипторам класса coordX, coordY Point1 по этим же именам?
print(pt2.coordX, pt2.coordY)               # дело в приоритете - если в самом классе Point1 или экземпляре класса pt  имеется такое же имя дескриптора как локальное св-во - то приоритет отдается вызову дескриптора


# Дескрипторы в Python бывают двух видов: для данных(data-descriptor) и для не данных (non-data descriptor)
# Последний (non-data descriptor) отличается тем, что реализует только один метод __get__

class NoDataDescr:                          # создадим класс дескриптора "не дата"
    def __set_name__(self, owner, name):
        self.__name = name

    def __get__(self, instance, owner):     # у него реализован только метод __get__ , методов set, del нет
        return "NoDataDescr __get__"



class CoordValue2:  # Дескрипторы это класс CoordValue1 в котором определены специальные методы get, set, del - чаще всего используются

    def __set_name__(self, owner, name):
        print(name)
        self.__name = name

    def __get__(self, instance, owner):
        return instance.__dict__[self.__name]

    def __set__(self, instance, value):
        instance.__dict__[self.__name] = value



class Point2:
    noData = NoDataDescr()                  # создадим в классе Point2 дескриптор noData и попытаемся в него что-то записать pt.noData = "Hello" - ошибок не будет

    coordX = CoordValue2()
    coordY = CoordValue2()

    def __init__(self, x = 0, y = 0):
        self.coordX = x
        self.coordY = y

pt1 = Point2(7, 8)
pt2 = Point2(70, 80)
print(pt1.coordX, pt1.coordY)
print(pt2.coordX, pt2.coordY)

pt.noData = "Hello"                        # запишем в дескриптор noData строку "Hello" - ошибок не будет - выведем в консоль
print(pt.noData)                           # дескриптор noData пропадет, т.к. будет создано новое локальное св-во со значением "Hello"
                                           # далее будем работать с noData как со строкой а не дескриптором
                                           # если у нас есть дескриптор NoDataDescr, тот который передает какие-то данные, то его можно использовать
                                           # только на прием данных __get__, записывать туда что-то уже нельзя.
